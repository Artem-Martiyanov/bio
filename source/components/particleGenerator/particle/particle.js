import './particle.css'const generateRandomNum = (min, max) => Math.round(min - 0.5 + Math.random() * (max - min + 1))const createParticle = (size, sizeDispersion, color) => {  if (size <= sizeDispersion) {    throw new Error(`sizeDispersion: ${sizeDispersion} should not be more than size: ${size}`)  }  const particle = document.createElement('div')  const delta = generateRandomNum(-2, 2)  particle.classList.add('particle')  particle.style.width = size + delta + 'px'  particle.style.height = size + delta + 'px'  particle.style.background = color  return particle}export class Particle {  /**   * Частица   *   * @description Частица создаётся с псевдослучайным translate по X и Y осям и сразу движется   *              к точке смещения, после окончания transition, частица удаляется.   *              - Регулировать время жизни частицы в CSS файле.   *              - Не рекомендуется ставить большое время жизни, это спровоцирует высокую   *              нагрузку на CPU и GPU, т.к. частицы не знают и не контролируют их общее количество.   *   * @param {Number} size - Базовый размер частицы (px) [3...infinity]   * @param {Number} sizeDispersion - Разброс размера частицы (px) [0...particleSize - 1]   * @param {String} color - Цвет частицы [hex, rgb, rgba, hsl]   */  constructor(size, sizeDispersion, color) {    this.parent = document.querySelector('[data-particle-effect]')    if (this.parent) {      this.particle = createParticle(size, sizeDispersion, color)      this.parent.insertAdjacentElement('afterbegin', this.particle)      window.setTimeout(() => this.#move(), 0)      this.particle.addEventListener('transitionend', this.#destroy)    }  }    #move() {    const getRand = () => {      const result = generateRandomNum(0, 100)      const probability = generateRandomNum(0, 100)      return probability > 50 ? result * -1 : result    }        const dX = getRand()    const dY = getRand()        this.particle.style.transform = `translate(${dX}vw, ${dY}vh)`    this.particle.style.opacity = '0'  }    #destroy(e) {    if (e.target.parentNode) {      e.target.parentNode.removeChild(e.target)    }  }}